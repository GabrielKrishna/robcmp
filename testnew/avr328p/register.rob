
type UCSRA {
    MPCM0 = false;
    U2X0 = false;
    UPE0 = false;
    DOR0 = false;
    FE0 = false;
    UDRE0 = false;
    TXC0 = false;
    RXC0 = false;
}

type UCSRB {
    TXB80 = false;
    RXB80 = false;
    UCSZ02 = false;
    TXEN0 = false;
    RXEN0 = false;
    UDRIE0 = false;
    TXCIE0 = false;
    RXCIE0 = false;
}

type UCSRC {
    UCPOL0 = false;
    UCSZ0 = int2(0);
    USBS0 = false;
    UPM0 = int2(0);
    UMSEL0 = int2(0);
}

/* USART0 control status register A */
register UCSRA UCSR0A at 0xc0;

/* USART0 control status register B */
register UCSRB UCSR0B at 0xc1;

/* USART0 control status register C */
register UCSRC UCSR0C at 0xc2;

register int16 UBRR0 at 0xc4;
register int8 UDR0 at 0xc6;

void start(int16 baud) {
    // set baudrate
    UBRR0 = int16(((16000000 / (16 * baud)) -1));
        //(((F_CPU) + 8 * (BAUD)) / (16 * (BAUD)) -1)
        //UBRR0 = int16(((16000000 + 8*baud)/16*baud)-1);

    // use 2x
    UCSR0A.U2X0 = false;

    // 8 bit
    UCSR0B.UCSZ02 = false;
    UCSR0C.UCSZ0 = 0x3;

    // no parity
    UCSR0C.UPM0 = 0x0;

    // 1 stop bit
    UCSR0C.USBS0 = false;

    UCSR0B.RXEN0 = true;
    UCSR0B.TXEN0 = true;
}

void write(int8 c) {
    while UCSR0A.UDRE0 == false;
    UDR0 = c;
}

int16 main() {
    a = 0;
    if UCSR0A.UDRE0 == true {
        a = 1;
    }
    start(9600);
    write(65);
    write(66);
    write(67);
    write(10);
	asm "sleep";
	return 0;
}
