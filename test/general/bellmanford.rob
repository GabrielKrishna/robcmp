/* vim: set tabstop=4:softtabstop=4:shiftwidth=4:noexpandtab */ 

const INT_MAX = 9999;

// edges (u,v,w)
graph =
	{{0, 1, -1}, {0, 2,  4}, {1, 2, 3},  
	 {1, 3,  2}, {1, 4,  2}, {3, 2, 5}, 
	 {3, 1,  1}, {4, 3, -3}};

// expected distances
dise = {0, -1, 2, -2, 1};

// Initialize distance of all vertices. 
dis = {INT_MAX : 5};

bool bellmanford(int16 V, int16 src) {

	// Number of edges
	E = graph.rows;
  
	// initialize distance of source as 0 
	dis[src] = 0;
  
	/* Relax all edges |V| - 1 times. A simple 
	 * shortest path from src to any other 
	 * vertex can have at-most |V| - 1 edges
	 */
	i = 0;
	while(i < (V-1)) {
		j = 0;
		while(j < E) {
			d = dis[graph[j][0]] + graph[j][2];
			if (d < dis[graph[j][1]]) {
				dis[graph[j][1]] = dis[graph[j][0]] + graph[j][2];
			}
			j++;
		}
		i++;
	}
  
	/* check for negative-weight cycles. 
	 * The above step guarantees shortest 
	 * distances if graph doesn't contain 
	 * negative weight cycle. If we get a 
	 * shorter path, then there is a cycle.
	 */
	i = 0;
	while(i < E) {
		x = graph[i][0];
		y = graph[i][1];
		weight = graph[i][2];
		if (dis[x] != INT_MAX and dis[x] + weight < dis[y]) {
			//print "Graph contains negative weight cycle\n";
			return false;
		}
		i++;
	}

	return true;
}

int16 main() {
	r = bellmanford(5, 0);
	if r == false {
		return 1;
	}
	
	i = 0;
	while i < dis.size {
		if dis[i] != dise[i] {
			return 1;
		}
		i++;
	}
	return 0;
}

