
use avr5mcu;

type UCSRA {
    MPCM0 = false;
    U2X0 = false;
    UPE0 = false;
    DOR0 = false;
    FE0 = false;
    UDRE0 = false;
    TXC0 = false;
    RXC0 = false;
}

type UCSRB {
    TXB80 = false;
    RXB80 = false;
    UCSZ02 = false;
    TXEN0 = false;
    RXEN0 = false;
    UDRIE0 = false;
    TXCIE0 = false;
    RXCIE0 = false;
}

type UCSRC {
    UCPOL0 = false;
    UCSZ0 = int2(0);
    USBS0 = false;
    UPM0 = int2(0);
    UMSEL0 = int2(0);
}

/* USART0 control status register A */
register UCSRA UCSR0A at 0xc0;

/* USART0 control status register B */
register UCSRB UCSR0B at 0xc1;

/* USART0 control status register C */
register UCSRC UCSR0C at 0xc2;

/* USART0 baud rate register, 12 bits*/
register uint16 UBRR0 at 0xc4;

/* USART0 byte to send/received */
register uint8 UDR0 at 0xc6;

type avr5_serial {

    void start(avr5mcu mcu, int32 baud) {
        // use 2x
        UCSR0A.U2X0 = false;
        
        multipl = 16;
        if UCSR0A.U2X0 == true {
            multipl = 8;
        }

        div = int32(multipl) * baud;
        velocity = (mcu.clock() / div) - 1;

        // set baudrate
        UBRR0 = int16(velocity);

        // 8 bit
        UCSR0B.UCSZ02 = false;
        UCSR0C.UCSZ0 = 0x3;

        // no parity
        UCSR0C.UPM0 = 0x0;

        // 1 stop bit
        UCSR0C.USBS0 = false;

        // enable tx and rx
        UCSR0B.RXEN0 = true;
        UCSR0B.TXEN0 = true;
    }

    void write(uint8 c) {
        while UCSR0A.UDRE0 == false;
        UDR0 = c;
    }

    uint8 read() {
        while UCSR0A.RXC0 == false;
        return UDR0;    
    }
    
    bool has_data() {
        return UCSR0A.RXC0;
    }
        
}
